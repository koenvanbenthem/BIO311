\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{bbold}
\usepackage{tikz}
%\usepackage{silence}
\usepackage{mdframed}
%\WarningFilter{mdframed}{You got a bad break}
\usepackage[colorinlistoftodos]{todonotes}
%\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{color}
\colorlet{exampcol}{blue!10}
\usepackage{multicol}
\usepackage[answerdelayed]{exercise}
\usepackage{booktabs}
\usepackage{caption}

\title{BIO311: Population Ecology\\ \textit{Prac 9: Population Matrices \& LTRE}}

\setcounter{tocdepth}{1} % Determines the depth of the table of contents;; 0:chapters, 1: chapters and sections, 2: chapters,sections and subsections

%\renewcommand{\theExercise}{\thechapter.\arabic{Exercise}}%

\begin{document}
\input{../authors}
<<setup, cache=FALSE, include=FALSE>>=
opts_chunk$set(dev="tikz",tidy=F,dev.args=list(pointsize=7.5))
options(width=60)

@

<<setparameters,echo=FALSE,include=FALSE>>=

@
\maketitle
\tableofcontents
\vspace{3cm}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% LTREs %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Life Table Response Experiment}
Life table response experiments (LTREs) are used to assess which  differences in vital rates lead to a change in $\lambda$ in an experimental design. The experiment you performed on the rotifers is well suited to be analysed by an LTRE. More information on the LTREs can be find in Caswell (2001) \textit{Matrix population models}, this is also the book that we based the theoretical background of this practical on. Before analysing the rotifer data, we will first perform a simple LTRE analysis on different data. During this part of the practical, we will write some of the functions that we will use later to analyse the rotifer data.

\subsection{Comparison of two Leslie matrices}
To start, we will examine two populations of yellow-necked mice. 

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{mouse.jpg}
\caption{\label{fig:mice}yellow-necked mouse, from wikipedia.}
\end{figure}

This species lives mostly in woodlands and it is suspected that its distribution is limited by altitude. Let us compare a population living in the mountain (population $\boldsymbol{M}$) with a population living in the plain (population $\boldsymbol{P}$) to see if the altitude is a limiting distribution factor. This species can be described by a life-cylce in two stages; juveniles and adults. Thus the matrices describing those populations are given by:
<<t20,echo=F,eval=T, include=FALSE>>=
P<-matrix(c(0,0.25,2,0.5), nrow=2)
M<-matrix(c(0,0.2,1.9,0.45), nrow=2)

library(popbio)
lamP<-lambda(P)
lamM<-lambda(M)
lamP
lamM
@
<<numm_approx_calc,echo=FALSE>>=
A<-matrix(runif(4),ncol=2)
sens <- function(A){
  da <- 1e-4
  lam <- eigen(A)$value[1]
  dim <- ncol(A)
  output <- matrix(NA,ncol=dim,nrow=dim)
  for(i in 1:nrow(A)){
    for(j in 1:ncol(A)){
      TempA <- A
      TempA[i,j] <- A[i,j] + da
      TemLam <- eigen(TempA)$value[1]
      output[i,j] <- (TemLam - lam) /da
    }
  }
  return(output)
}
@

\begin{equation}
\boldsymbol{P}=\begin{pmatrix}
\Sexpr{P[1,1]}&\Sexpr{P[1,2]}\\
\Sexpr{P[2,1]}&\Sexpr{P[2,2]}
\end{pmatrix}
\end{equation}
and
\begin{equation}
\boldsymbol{M}=\begin{pmatrix}
\Sexpr{M[1,1]}&\Sexpr{M[1,2]}\\
\Sexpr{M[2,1]}&\Sexpr{M[2,2]}
\end{pmatrix}
\end{equation}
Find the asymptotic growth rates of these populations. You can see that they differ. We would now like to investigate which matrix elements contribute the most to the difference in the asymptotic growth rates. As before, we will start by looking at the sensitivities. This time however, we will write a function that calculates the sensitivities of $\lambda$ to the matrix elements. Writing a general function, will make it easier for us to calculate sensitivities for matrices later. We provide two options for doing so: by numerical perturbation as we did in the previous practical, or by using the exact solution. The latter is conceptually more difficult, but more precise and less code. You may choose yourself which one you want to implement.

\begin{mdframed}\textbf{A: Sensitivities using perturbations}\\
<<numm_approx,echo=FALSE>>=
A<-matrix(runif(4),ncol=2)
sens <- function(A){
  da <- 1e-4
  lam <- eigen(A)$value[1]
  dim <- ncol(A)
  output <- matrix(NA,ncol=dim,nrow=dim)
  for(i in 1:nrow(A)){
    for(j in 1:ncol(A)){
      TempA <- A
      TempA[i,j] <- A[i,j] + da
      TemLam <- eigen(TempA)$value[1]
      output[i,j] <- (TemLam - lam) /da
    }
  }
  return(output)
}
@
<<numm_approx_text,eval=FALSE>>=
# We are going to make a function with the name
# sens, that takes 1 input variable. We call this
# variable A. Everything between { and } is the code
# of the function
sens <- function(A){

  da <- 1e-4 # define a small perturbation
  lam <- ...  # extract the dominant eigenvalue of A
  dim <- ... # store the size of A. Use ncol()
             # use ?ncol to see what it does
  
  # finally, create an empty matrix to store your results in
  output <- matrix(NA,ncol=dim,nrow=dim)
  
  # loop over all indices [i,j] in A, both the rows and the columns
  # to calculate the sensitivity of each and every index
  for(i in ...){
    for(j in ...){
      TempA <- A # we copy the matrix
      TempA[i,j] <- ... # we perturb one element
      TemLam <- ... # calculate the dominant eigenvalue of the perturbed matrix
      output[i,j] <- ... # calculate the sensitivity of lambda to the element (dlambda/da)
    }
  }
  
  return(output) # The end of the function is reached, we now return the value of output
}
@

\end{mdframed}

\begin{mdframed}
\textbf{B: Sensitivities using the exact solution}\\
Here we will use the formula that was shown in the lecture:
\begin{equation}
\begin{pmatrix} 
\frac{\partial \lambda}{\partial a_{1,1}} & \frac{\partial \lambda}{\partial a_{1,2}} & \dots & \frac{\partial \lambda}{\partial a_{1,N}} \\ 
\frac{\partial \lambda}{\partial a_{2,1}} & \frac{\partial \lambda}{\partial a_{2,2}} & \dots & \frac{\partial \lambda}{\partial a_{2,N}}\\
\vdots & \vdots & & \vdots \\
\frac{\partial \lambda}{\partial a_{N,1}} & \frac{\partial \lambda}{\partial a_{N,2}} & \dots & \frac{\partial \lambda}{\partial a_{N,N}} \\ 
\end{pmatrix}
=
 \frac{\vec{v} \vec{w}^T}{\vec{v}^T \vec{w}}
\end{equation}
Here, $\vec{w}$ and $\vec{v}$ are the dominant right and left eigenvector respectively. Furthermore $\vec{v}^T$ responds to the transpose of $\vec{v}$. Using this we can now wite a function to calculate the sensitivities:
<<exact_approach>>=
sens <- function(A){
  w <- eigen(A)$vector[,1]
  v <- eigen(t(A))$vector[,1]
  outcome <- v %*% t(w) / as.numeric(t(v)%*%w)
  return(outcome)
}
@
\end{mdframed}
This is a very good start! We now have a function that easily provides us with the sensitivity values for any matrix. All we have to do now to get the sensitivity of \texttt{P} is to type \texttt{sens(P)}. 

For this we describe the asymptotic growth rate of the mountain population matrix, $\boldsymbol{M}$, as a function of the asymptotic growth rate of the plain population matrix, $\boldsymbol{P}$ , our reference population plus a treatment effect:  

\begin{equation}\label{a}
\lambda^{(M)} \approx \lambda^{(P)}+\sum_{i,j}{(a^{(M)}_{ij}-a^{(P)}_{ij})} \frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
Let us work through the right part of this equation together. 
\begin{itemize}
\item $\lambda^{(P)}$ is the asymptotic growth rate of the $\boldsymbol{P}$ matrix. 
\item The term ${(a^{(M)}_{ij}-a^{(P)}_{ij})}$, is the change in the elements of the matrix due to the treatment effect, here the moutain habitat. It tells us how different an element in matrix $\boldsymbol{M}$ is from the element at the same position in matrix $\boldsymbol{P}$.
\item The last part, $\frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}$, is the sensitivities of the asymptotic growth rate of a "mid-way" matrix to elements of that "mid-way" matrix. This matrix is the mean between $\boldsymbol{P}$ and $\boldsymbol{M}$ and is thus given by 
\begin{equation}
\boldsymbol{A}=\frac{\boldsymbol{M}+\boldsymbol{P}}{2}
\end{equation}
The matrix $\boldsymbol{A}$ is used because we need a matrix to compare matrices $\boldsymbol{P}$ and $\boldsymbol{M}$ against. It is possible to use either matrix $\boldsymbol{P}$ or $\boldsymbol{M}$ instead but this would give more weight to the selected matrix. Therefore we use the matrix that lies just in between.
\item The multiplication of the sensitivities with the summation term defines how much the change in each elements of the matrix due to the treatment affects the asymptotic growth rate. In other word they are the contributions of the $a_{ij}$ to the effect of the habitat on the growth. It is necessary to do this because for example, a large difference between the elements in the same position may in fact have little effect on the growth if the senstitivity for this position is low. 
\end{itemize}

You may have recognized that equation \ref{a} is a linear equation ($y=b+ax$). This method makes the assumption that the relationship between the matrices is linear and that the slope of this equation is given by $\frac{ \partial\lambda^{A}}{\partial a^{A}_{ij}}$.


With equation \ref{a}, find the value of $\lambda^{(\boldsymbol{M})}$ using \texttt{R} and compare it to the value you found earlier. How different are they? More interestingly: which difference in the matrix elements is mainly responsible for this difference? Is it the juvenile survival, the adult survival or the reproductive rate?\\[1.5ex]

\textit{Hint} Find the "mid-way" matrix. For the sensitivities.
<<t21,echo=F,eval=T, results='hide'>>=
P<-matrix(c(0,0.25,2,0.5), nrow=2)
M<-matrix(c(0,0.2,1.9,0.45), nrow=2)

#Short cut:
library(popbio)

A<-(M+P)/2
lamP<-lambda(P)
lamM<-lambda(M)
lamM2<-lamP+sum((M-P)*sensitivity(A))


#alternative complete code:
a<-0.01
Sen<-matrix(NA,2,2)
lamA<-lambda(A)
for (i in 1:2){
  for (j in 1:2){
  Ap<-A
  Ap[i,j]<-A[i,j]+a
  Sen[i,j]<-(lambda(Ap)-lamA)/a
}
}
Sen
lamP<-which(eigen(P)$values==max(eigen(P)$values))
lamP+sum((M-P)*Sen)


@
\subsection{Fixed Factorial Designs (Theory)}
Factorial LTRE allows the examination of the effects of several treatments and their interactions. This is the case for your rotifer data where you have a "layer" treatment, a "pollution" treatment and a "species" treatment. Not all the combinations were investigated though; the layers "recovery" and "pollution" contained only the species BU whereas the layers "commercial" and "postpollution" contained only species BC. What difficulty would this pose if you want to compare the species to each other? Because of this, we cannot make a full factorial LTRE on the rotifer data, but we will examine subsets of the full dataset.


For example let us consider the species BU which has two treatments of the type "layer": the layers "recovery" ($r$) and "pollution" ($p$). For each of these layers it has 3 possible levels for the copper treatment: "low" ($l$), "medium" ($m$) and "high" ($h$). We thus have two factors, one with two levels, the second with three levels.

A factorial LTRE is similar to a one-way LTRE; we want to find which differences in matrix elements between a focal matrix and a reference matrix contribute the most to the difference in $\lambda$ between the two matrices. Let us take the matrix "recovery" and "low" which we call $\boldsymbol{M}^{r,l}$ as the focal matrix, for this we average the rates over all the $6$ replicates that were subject to this treatment ($r,l$). We compare it to the matrix naive to any treatment, which we call $\boldsymbol{M}^{..}$. This matrix is obtained from taking the average rates for all the matrices that we are comparing to each other (that is in this case the average of $\boldsymbol{M}^{r,l}$,$\boldsymbol{M}^{r,m}$,$\boldsymbol{M}^{r,h}$,$\boldsymbol{M}^{p,l}$,$\boldsymbol{M}^{p,m}$ and $\boldsymbol{M}^{p,h}$). Again we are interested in understanding the effect of the different treatments on the asymptotic growth rates.
\begin{equation}\label{b}
\lambda^{r,l}=\lambda^{..}+\alpha^{r}+\beta^{l}+(\alpha \beta)^{r,l}
\end{equation}
Equation \ref{b} tells us that $\lambda^{r,l}$ can be found from $\lambda^{..}$ plus an effect from the layer "recovery", an effect from the pollution "low" and an interaction between the two treatments.

To isolate the effect of each treatment, we need to look at them separately. So we examine a matrix $\boldsymbol{M}^{r.}$, where the effect of pollution is ignored. The rates of this matrix are calculated as the average of all the matrices with the layer "recovery". 
\begin{equation}\label{c}
\alpha^{r}=\sum_{ij}(a^{r.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
The structure of equation \ref{c} is the same as the last part of equation \ref{a}. The matrix $\boldsymbol{A}$ is again a "mid-way" matrix between $\boldsymbol{M}^{r.}$ and $\boldsymbol{M}^{..}$. $\alpha^{r}$ tells us how large the effect of the treatment "layer" is on the asymptotic growth rate. If we want to know which matrix elements are responsible for this effect, we need to look at the separate contributions to $\alpha^r$ ($(a^{r.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}$). Analogously we can also calculate $\alpha^p$.

We do the same for the second factor. We examine a matrix $\boldsymbol{M}^{.l}$, where the effect of the layer is ignored: 
\begin{equation}\label{d}
\beta^{l}=\sum_{ij}(a^{.l}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{B}}{\partial a^{B}_{ij}}
\end{equation}
For the interaction effect, we apply the same logic. We examine a matrix $\boldsymbol{M}^{rl}$ where both the effects of the layer and the pollution are taken into account so as to capture the effect of the interaction between the two factors. Because we want to isolate the interaction effect, we need to remove the effects of the layer and copper treatment.
\begin{equation}
(\alpha \beta)^{rl}=\sum_{ij}(a^{rl}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}} -\alpha^{r}-\beta^{l}
\end{equation}
So far we have considered only the effect of the layer "recovery" and the pollution "low". Of course this can be extended to all other layers of all treatments. So in general the equations become for $k$ the level of treatment $1$ and $m$ the level of treatment $2$.

\begin{equation}\label{f}
\lambda^{k,m}=\lambda^{..}+\alpha^{k}+\beta^{m}+(\alpha \beta)^{k,m}
\end{equation}
\begin{equation}\label{e}
\alpha^{k}=\sum_{ij}(a^{k.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}
\end{equation}
\begin{equation}
\beta^{m}=\sum_{ij}(a^{.m}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{B}}{\partial a^{B}_{ij}}
\end{equation}
\begin{equation}
(\alpha \beta)^{km}=\sum_{ij}(a^{km}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}} -\alpha^{k}-\beta^{m}
\end{equation}
In these equations:
\begin{align}
A &= \frac{\boldsymbol{M^{k.}} + \boldsymbol{M^{..}}}{2} & B &= \frac{\boldsymbol{M^{.m}} + \boldsymbol{M^{..}}}{2} & C &= \frac{\boldsymbol{M^{km}} + \boldsymbol{M^{..}}}{2}
\end{align}
LTREs provide additional information to the growth rate as it describes how the different treatments affect the growth rate. In particular, LTRE allow a detailed comparison of the effect of a treatment on growth rate by examining the contribution of each survival and fertility rate to the gorwth rates of populations subjected to different treatment levels. For example, the graph below depicts the contribution of each element of populations under different copper levels to the growth rate. Each bar describes what is the contribution of an element to the growth rate when subjected to a given treatment level. What conclusions can you draw from this graph?



<<thypgraph,echo=F, eval=T, results='asis',fig.align='center'>>=
#Copper
Copper <- matrix(c(0.06, -0.08, -0.007, -0.07, 0.01, 0.04, 0.04, -0.05, 0.01), nrow=3, ncol=3)
colnames(Copper) <- c("High", "Medium", "Low")
rownames(Copper) <- c("Pj", "F", "Pa")
Coppert<-t(Copper)

par(mar=c(6.1, 6.1, 4.1, 5.1), xpd=TRUE)
barplot(Coppert,xaxt='n', xlab="", ylab="Parameters contribution",ylim=c(-0.1, 0.1), xlim=c(0,14), col=c("brown","orange", "yellow"), beside=TRUE, main="Copper level")
segments(-1,0, 13,0)
legend("topleft", 
     c("High", "Medium", "Low"), fill=c("brown","orange", "yellow"),  bty="n")
axis(side=1, at=c(3,7,11), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)

@

\section{Rotifer data analysis}
In this section, you will apply the factorial LTRE to the rotifer data to compare the layers "pollution" and "recovery". The second factor is the copper treatment with the levels "low", "high", "medium".

\subsection{Rate estimation}
Before we can start with the analysis of the population matrices, we first need... the matrices and thus the rates (survival and reproduction). Here, we have only two stages: juveniles and adults, so we consider a $2\times 2$ matrix. First, we load in the data:
<<LoadDat>>=
#Rot <- read.csv("/Users/koen/Documents/Given Courses/BIO311/Prac 9/rotifer_data.csv")[,2:9]
Rot <- read.csv("rotifer_data.csv")[,2:9]
table(Rot$Copper)
Rot$Copper[Rot$Copper==1000] <- 100
table(Rot$Layer)
Rot$Layer[Rot$Layer=="Post"] <- "post"
Rotti<-reshape(Rot,timevar="Day",idvar=c("Clone","Copper","Layer"),direction="wide")
Rates <- Rotti[,1:3] 
@
We shall now first calculate the adult survival rate for the period from day $1$ to day $2$.
<<Rates>>=
# 1 --> 2
Rates$Sa1 <- (Rotti$Live_Adult.1 - Rotti$Dead_Adult.2)/ Rotti$Live_Adult.1
Rates$M1 <- (Rotti$Live_Adult.2 + Rotti$Dead_Adult.2 - Rotti$Live_Adult.1) / Rotti$Live_Juv.1
Rates$Sj1 <- (Rotti$Live_Juv.1 - (Rotti$Live_Adult.2 + Rotti$Dead_Adult.2 - Rotti$Live_Adult.1) - Rotti$Dead_Juv.2)/Rotti$Live_Juv.1
Rates$R1 <- (Rotti$Live_Juv.2 - Rotti$Live_Juv.2*Rates$Sj1) / Rotti$Live_Adult.1

# 2 --> 3
Rates$Sa2 <- (Rotti$Live_Adult.2 - Rotti$Dead_Adult.3)/ Rotti$Live_Adult.2
Rates$M2 <- (Rotti$Live_Adult.3 + Rotti$Dead_Adult.3 - Rotti$Live_Adult.2) / Rotti$Live_Juv.2
Rates$Sj2 <- (Rotti$Live_Juv.2 - (Rotti$Live_Adult.3 + Rotti$Dead_Adult.3 - Rotti$Live_Adult.2) - Rotti$Dead_Juv.3)/Rotti$Live_Juv.2
Rates$R2 <- (Rotti$Live_Juv.3 - Rotti$Live_Juv.3*Rates$Sj2) / Rotti$Live_Adult.2

# Averages
Rates$SaM <- (Rates$Sa1 + Rates$Sa2)/2
Rates$MM <- (Rates$M1 + Rates$M2)/2
Rates$SjM <- (Rates$Sj1 + Rates$Sj2)/2
Rates$RM <- (Rates$R1 + Rates$R2)/2

Rates2 <- Rates[,c('Copper','Layer','SaM','MM','SjM','RM')]
Rates3 <- aggregate( .~ Copper+Layer,Rates2,mean)
Rates3$lambda <- NA
for(i in 1:nrow(Rates3)){
  Mat <- matrix(c(Rates3$SjM[i],Rates3$MM[i],Rates3$RM[i],Rates3$SaM[i]),nrow=2)
  Rates3$lambda[i] <- eigen(Mat)$values[1]
}
@

<<LTRE_FACT>>=

#### FACTORIAL DESIGN LTRE
library(popbio)

LTRE <- function(A,B){
  M <- (A+B)/2
  (A-B) * sensitivity(M)
}

MatMean <- matrix(c(mean(Rates3$SjM),mean(Rates3$MM),mean(Rates3$RM),mean(Rates3$SaM)),nrow=2)

### Copper treatment
temp  <- Rates3[,c('Copper','SaM','MM','SjM','RM')]
tempc <- aggregate(.~Copper,temp,mean)
copper <- list(3)
for(i in 1:3){
  mat <- matrix(c(tempc$SjM[i],tempc$MM[i],tempc$RM[i],tempc$SaM[i]),nrow=2)
  copper[[i]] <- LTRE(mat,MatMean)
}
names(copper) <- tempc$Copper

### Layer treatment
temp  <- Rates3[,c('Layer','SaM','MM','SjM','RM')]
templ <- aggregate(.~Layer,temp,mean)
layer <- list(3)
for(i in 1:3){
  mat <- matrix(c(templ$SjM[i],templ$MM[i],templ$RM[i],templ$SaM[i]),nrow=2)
  layer[[i]] <- LTRE(mat,MatMean)
}
names(layer) = templ$Layer

### Interactions
temp2  <- Rates3[,c('Copper','Layer','SaM','MM','SjM','RM')]
interaction <- list(9)
for(i in 1:9){
  mat <- matrix(c(temp2$SjM[i],temp2$MM[i],temp2$RM[i],temp2$SaM[i]),nrow=2)
  interaction[[i]] <- LTRE(mat,MatMean) - layer[[as.character(temp2$Layer[i])]] - copper[[as.character(temp2$Copper[i])]]
}

### Plots
par(mfrow=c(1,2))
barplot(matrix(unlist(copper),nrow=4),beside=F)
barplot(matrix(unlist(copper),nrow=4),beside=T)

barplot(matrix(unlist(layer),nrow=4),beside=T)
barplot(matrix(unlist(interaction),nrow=4),beside=T)

## Summary
sapply(copper,sum)
sapply(layer,sum)
sapply(interaction,sum)

### Outcome check

Rates3$lambda2 <- NA
Rates3$lambda3 <- NA
lam_mean <- lambda(MatMean)
for(i in 1:9){
  Rates3$lambda2[i] <- lam_mean + sum(copper[[as.character(Rates3$Copper[i])]]) +sum(layer[[as.character(Rates3$Layer[i])]]) + sum(interaction[[i]])
  Rates3$lambda3[i] <- lam_mean + sum(copper[[as.character(Rates3$Copper[i])]]) +sum(layer[[as.character(Rates3$Layer[i])]])
}
Rates3
@

\subsection{LTRE}
\begin{enumerate}
\item Because in the lab, you have made several replicates for each treatment combination, you now have a rate per replicate. We are however interested in the average rates per treatment. We want one juvenile survival rate, one adult survival rate and one fertility rate per population, per copper level and per species. For this you can use the \texttt{aggregate()} function that we have seen in practical $6$ and find the mean. Use the function three times seperately, once for each of the rates that we are interested in. Store the results in a variable. Use \texttt{?aggregate} to see how to use the function. You will need to use one special argument: \texttt{na.rm=TRUE}. This is to make sure that when there are $NA$s in the dataset, the function ignores them and still returns a value.
\item Now you have three separate lists. You want to group them. For this you can adapt the following lines of code. Use the names of the variables that you specified in the previous step.
<<t23,echo=T, eval=F>>=
younewdata1<-merge(SurvJuv, SurvAdu, by=c(1,2,3)) 
#by set the column by which to merge the two elements

younewdata2<-merge(younewdata1, Fertility, by=c(1,2,3))
@
You can in addition give a more meaningful name to the columns by using:
<<t24,echo=T, eval=F>>=
colnames(younewdata2)<-c("name of col1", 
"name of col2", "name of col3", 
"name of col4", "name of col5", "name of col6")
@
\item We mentioned that we are only interested at the moment in the layer "Recovery" and "Pollution". Both contained the species BU. Thus, select only the BU species with the \texttt{subset} function that we also used in practical $6$.
\item Below is a useful function for the LTRE. It allows you to extract a specific matrix per treatment by using \texttt{get\_matrix}. You need to give it the following arguments 1) the dataset from which you want to extract the matrix, 2) the name of the layer that you are interested in (for example "Pollution"), and 3) the name of the copper level (for example "high"). You do not need to understand the details of this code. If you run this code once during your \texttt{R}-session, \texttt{R} will remember it and every time you type \texttt{get\_matrix(data,layer,copper)} it will execute that code.
<<t26,echo=T, eval=F>>=
#code for function to extract matrices from the dataset#
get_matrix<-function(roti,pop,cop){
  if(!pop %in% c(levels(roti$Population),"mean")){
    warning("Something went wrong, give the instructors 
            a cookie and they may help you out:
            \n------------------------\n ",pop,
        " is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(!cop %in% c(levels(roti$Copper),"mean")){
    warning("Something went wrong, give the instructors 
            a cookie and they may help you out:
            \n------------------------\n ",cop," 
            is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(pop=="mean" & cop=="mean"){
    i<-1:length(roti$Copper)
  }else if(pop=="mean"){
    i<-which(roti$Copper==cop)
  }else if(cop=="mean"){
    i<-which(roti$Population==pop)
  }else{
    i<-which(roti$Population==pop & roti$Copper==cop)  
  }
  
  A<-matrix(c(0, mean(roti$Pj[i]), 
        mean(roti$F[i]), mean(roti$Pa[i])), nrow=2, ncol=2)
  return(A)
  }
#end of the function#
@
\item With the \texttt{get\_matrix} function, extract the matrix for each treatment combinations ($6$ matrices in total). You need to specify the dataset in the first position, in the second position you need to specify the layer and in the third position the copper level.
\item Get the growth rate $\lambda$ of each of these matrix.
\item Now we get to the LTRE. Let us isolate the effect of the first treatment which is the layer. This factor has two levels; pollution and recovery. What we need to do is to implement equation \ref{e} in \texttt{R}. Let us find the $\alpha$ for the level "pollution" first; $\alpha^p$. 
\begin{enumerate}
\item Find the matrix $\boldsymbol{M}^{..}$. The rates of this matrix are the averages of the rates of all the matrices of the BU species. For this you can use the \texttt{get\_matrix} function.  The second argument concerns the layer, but here we want the mean rate over all the layers, we have written the function such that you can achieve this by typing "mean" as an argument for the layer. The same holds for the third argument.
\item Next you need the mean pollution matrix, $\boldsymbol{M}^{p.}$. Again, use the \texttt{get\_matrix} function.\\[1.5ex] 
\textit{small tip} Here you can do a little trick to be able to use the code later on a different subset of your dataset. Before using the \texttt{get\_matrix} function, set a new name to your focal layers like in the code below. Then in \texttt{get\_matrix}, instead of calling for "Pollution", call for \texttt{yourname1}.

<<tpos,echo=T, eval=F>>=
yourname1<-'Pollution'
yourname2<-'Recovery'

@
\item Find the $\lambda$ for this matrix.
\item Find the "mid-way" matrix between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$. This is the mean matrix between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$.
\item For equation \ref{e}, you need the summation term and the sensitivity of the "mid-way" matrix. Let us look first at the summation term. You need the difference between the elements of matrix $\boldsymbol{M}^{p.}$ and of matrix $\boldsymbol{M}^{..}$. Thus take $(\boldsymbol{M}^{p.} - \boldsymbol{M}^{..})$. 
\item To find the sensitivity of the "mid-way" matrix, use the function \texttt{sensitivity} from the package \texttt{popbio} (see subsection \textit{sensitivity}). 
\item Finally, multiply the substraction matrix by the sensitivity matrix (not a matrix multiplication!) and save this in a matrix.
\item The sum of this matrix is your $\alpha^p$, the effect of the layer "Pollution" on the asymptotic growth rate. The separate entries of this matrix show how much each element of the population matrices contributes to the difference in $\lambda$ between them.
\item Store this matrix because the different elements of the matrix are what we are ultimately interested in. Check whether the effect you found indeed explains the difference between $\boldsymbol{M}^{..}$ and $\boldsymbol{M}^{p.}$.
\end{enumerate}
\item Repeat the same proceedure to find the second $\alpha$, $\alpha^r$ and store the separate contributions $(a^{k.}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{A}}{\partial a^{A}_{ij}}$. DO the same for the three values for $\beta$ and finally for the interactions. For the separate contribution of the interactions $(a^{km}_{ij}-a^{..}_{ij}) \frac{\partial\lambda^{C}}{\partial a^{C}_{ij}}$, do not forget to substract the corresponding contributions from the $\alpha$ and $\beta$. 
\item Once you have all the contributions of all the treatments, you may want to compare them. A possible graphs is a bar plot representing on the same graph the contribution to each parameter of each level of a factor, see for an example the graph above. If you agree that these sort of graphs are interesting, you can follow the next instructions. Feel free however to follow a different logic to produce the same graphs or to present your results in a different way. We do not claim to provide the most efficient code; any comments on how to improve the code are welcome.
\begin{enumerate}
\item Let us first look at the effect of the layer on the rates. One way of doing this is first to transform your matrices into vectors, using the \texttt{as.vector()} function and then combine the vector of each matrix into an array with \texttt{cbind()}. (you can actually ignore the first element of the matrices, the transition from juvenile to juvenile because it is always zero by selecting the vector elements 2 to 4). The columns are the layers and the row the rates. 
\item You can now use the \texttt{barplot()} command to plot bar graphs. Specify \texttt{beside=TRUE} to see the bars next to each other rather than on top of each other.
\item You may see that each bar (color) represents a rate although it would be more informative if each bar would be a layer. To correct for this, you can take the transpose of the array by using the function \texttt{t()} (we have seen this earlier this practical) and do the bar plot of the transpose. 
\item There are a few arguments you may want to use in the \texttt{barplot()} command to improve the visual appearance of the graph such as \texttt{xlab=}, \texttt{ylab=}, \texttt{xlim=c()}, \texttt{ylim=c()}, \texttt{col=c("colorname")}, \texttt{main="yourtitle"}.
\item Additionally, you may want to specify a legend and an axis. This you can do with the commands \texttt{legend()} and \texttt{axis()}. Look them up in the help section to see how to use them.
\item Don't forget to save your figures! A detailed description is given at the end of practical 6.
\end{enumerate}
\item Repeat all of the steps above for the combinations of the layers "Commercial" \& "Postpollution" and of the layers "Postpollution" \& "Pollution".
\end{enumerate}
If you manage to go through all the steps describe above, you should now know the growth rate of your populations, have performed three LTRE analyses on your rotifer data and have plots to include in your report. The interpretation of the results is up to you.


\begin{center}
Good luck!
\end{center}

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{Hippocrate.jpg}
\caption{\label{fig:owl}random picture, from wikipedia.}
\end{figure}



<<tReco_vs_Post,echo=T, eval=T>>=

#Open data
rm(list = ls())
rot<-read.csv("BIO311_with_rates.csv", sep=",")
str(rot)


#Find the avg rate per treatment
Pj<-aggregate(rot$Pj, list(rot$Population, rot$Copper, rot$Species),
              na.rm=TRUE, FUN="mean")
Pj
Pa<-aggregate(rot$Pa, list(rot$Population, rot$Copper, rot$Species), 
              na.rm=TRUE, FUN="mean")
Pa
F<-aggregate(rot$F, list(rot$Population, rot$Copper, rot$Species),
             na.rm=TRUE, FUN="mean")
F
Surv<-merge(Pj, Pa,  by=c(1,2,3))
Surv


# Merge it into one dataset
Roti<-merge(Surv, F, by=c(1,2,3))

colnames(Roti)<- c("Population", "Copper", "Species", "Pj", "Pa", "F")
Roti

#Finding the lambda for each matrix (optional)
Roti$lambda<-NA

library('popbio')
for (i in 1:length(Roti$Pj)){
  M<-matrix(c(0, Roti$Pj[i], Roti$F[i], Roti$Pa[i]), nrow=2, ncol=2)
    
  Roti$lambda[i]<-lambda(M)
}
 Roti

#----------- code for function to extract matrices from the dataset-----------#
get_matrix<-function(roti,pop,cop){
  if(!pop %in% c(levels(roti$Population),"mean")){
    warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",
            pop," is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(!cop %in% c(levels(roti$Copper),"mean")){
    warning("Something went wrong, give the instructors a cookie and they may help you out:\n------------------------\n ",
            cop," is not a valid entry\n------------------------\n")
    
    return()
  }
  
  if(pop=="mean" & cop=="mean"){
    i<-1:length(roti$Copper)
  }else if(pop=="mean"){
    i<-which(roti$Copper==cop)
  }else if(cop=="mean"){
    i<-which(roti$Population==pop)
  }else{
    i<-which(roti$Population==pop & roti$Copper==cop)  
  }
  
  A<-matrix(c(0, mean(roti$Pj[i]), mean(roti$F[i]),
              mean(roti$Pa[i])), nrow=2, ncol=2)
  return(A)
  }
#--------------------------end of the function-----------------#

#Get the matrices we are interested in (for Species BC)
library(popbio)
a<-'Pollution'
ash<-'Poll' # Short name for layer a
b<-'Recovery'
bsh<-'Rec' # Short name for layer b

Rotisub <- subset(Roti, Roti$Population==a | Roti$Population==b)
Rotisub


#Here let us do the LTRE
#two factors: population (1) and Copper (2)
#The average matrix:
M<-get_matrix(Rotisub, "mean", "mean")

#First the effect of population (1)-> alpha
Pop1<-get_matrix(Rotisub, a, "mean")
#Population level 3->Postpollution
#Population level 1->Pollution 
     #Pollution
       #The mid-way matrix 
A<-((M+Pop1)/2)
alpha1<-(Pop1-M)*sensitivity(A)
alpha1

#Recovery
Pop2<-get_matrix(Rotisub, b, "mean")
       #The mid-way matrix 
B<-((M+Pop2)/2)
alpha2<-(Pop2-M)*sensitivity(B)
alpha2

#Second the effect of Copper (2)-> beta
hig<-get_matrix(Rotisub, "mean", "high")
med<-get_matrix(Rotisub, "mean", "medium")
low<-get_matrix(Rotisub, "mean", "low")
#Copper level 1->High
#Copper leve 2->Medium
#Copper leve 3->Low
     #High
       #The mid-way matrix 
#for beta:
C<-((M+hig)/2)
beta1<-(hig-M)*sensitivity(C)
beta1


  #Medium
       #The mid-way matrix 
#for beta:
D<-((M+med)/2)

beta2<-(med-M)*sensitivity(D)
beta2

  #Low
       #The mid-way matrix 
#for beta:
E<-((M+low)/2)

beta3<-(low-M)*sensitivity(E)
beta3


#Interactions

#Here let us extract the 6 matrices we need:
Pop1h<-get_matrix(Rotisub, a, "high")
Pop1m<-get_matrix(Rotisub, a, "medium")
Pop1l<-get_matrix(Rotisub, a, "low")

Pop2h<-get_matrix(Rotisub, b, "high")
Pop2m<-get_matrix(Rotisub, b, "medium")
Pop2l<-get_matrix(Rotisub, b, "low")

       #The mid-way matrix 
#for alpha:beta:
F<-((M+Pop1h)/2)

inter1<-((Pop1h-M)*sensitivity(F))-alpha1-beta1
inter1

       #The mid-way matrix 
#for alpha:beta:
G<-((M+Pop1m)/2)
#The loop

inter2<-((Pop1m-M)*sensitivity(G))-alpha1-beta2
inter2

#The mid-way matrix 
#for alpha:beta:
H<-((M+Pop1l)/2)

inter3<-((Pop1l-M)*sensitivity(H))-alpha1-beta3
inter3
#The mid-way matrix 
#for alpha:beta:

I<-((M+Pop2h)/2)
inter4<-((Pop2h-M)*sensitivity(I))-alpha2-beta1
inter4

#The mid-way matrix 
#for alpha:beta:
J<-((M+Pop2m)/2)
inter5<-((Pop2m-M)*sensitivity(J))-alpha2-beta2
inter5

#The mid-way matrix 
#for alpha:beta:
K<-((M+Pop2l)/2)
inter6<-((Pop2l-M)*sensitivity(K))-alpha2-beta3
inter6


######### ARRANGING THE DATA FOR PLOTTING ##############
#Copper
Copper <- cbind(as.vector(beta1)[2:4], as.vector(beta2)[2:4],
                as.vector(beta3)[2:4])
colnames(Copper) <- c("High", "Medium", "Low")
rownames(Copper) <- c("Pj", "F", "Pa")
Copper
Coppert<-t(Copper)

#Layer
Layer <- cbind(as.vector(alpha1)[2:4], as.vector(alpha2)[2:4])
colnames(Layer) <- c(a, b)
rownames(Layer) <- c("Pj", "F", "Pa")
Layer
Layert<-t(Layer)

#Interactions
Interactions <- cbind(as.vector(inter1)[2:4], as.vector(inter2)[2:4], 
                      as.vector(inter3)[2:4], as.vector(inter4)[2:4],
                      as.vector(inter5)[2:4], as.vector(inter6)[2:4])
colnames(Interactions) <- axislabels
rownames(Interactions) <- c("Pj", "F", "Pa")
Interactions
Interactionst<-t(Interactions)

# Plotting
ymin<-min(c(min(Layer),min(Copper),min(Interactions)))

ymax<-max(c(max(Layer),max(Copper),max(Interactions)))

ylim<-0.03+max(c(ymax,abs(ymin)))

limits<-c(-ylim,ylim)

#graphs
par(mfrow=c(1,3),mar=c(3,3,3,7))

barplot(Coppert,xaxt='n', xlab="", ylab="Parameters contribution",
        ylim=limits, xlim=c(0,14), col=c("brown","orange", "yellow"), 
        beside=TRUE, main="Copper level")
segments(-1,0, 13,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft", 
     c("High", "Medium", "Low"), fill=c("brown","orange", "yellow"),
     bty="n")
axis(side=1, at=c(3,7,11), labels=c( "Pj", "F", "Pa"), line=1,
     tick=FALSE)

barplot(Layert,xaxt='n', xlab="", ylab="", ylim=limits, xlim=c(0,14),
        col=c("blue","lightblue"), beside=TRUE, main="Layer")
segments(-1,0, 10,0)
par(mar=c(5.1, 5.1, 4.1, 5.1), xpd=TRUE)
legend("topleft",
     c(a,b), fill=c("blue","lightblue"), bty="n")
axis(side=1, at=c(2,5,8), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)



#Interaction
#Layer
axislabels<-c()
for(i in c(ash,bsh)){
  for(j in c("H","M","L")){
    axislabels<-c(axislabels,paste(i,j,sep=""))
  }
}

axislabels2<-c()
for(i in c(ash,bsh)){
  for(j in c("$+$","$\\pm$","$-$")){
    axislabels2<-c(axislabels2,paste(i,j,sep="; "))
  }
}


rainbow(6,start = 0, end = 0.5, alpha = 0.7)
library("RColorBrewer")

barplot(Interactionst, xaxt='n', xlab="", ylab="", ylim=limits, xlim=c(0,20),
        col=brewer.pal(6, "Set3") , beside=TRUE, main="Interactions")
segments(-1,0, 20,0)
par(mar=c(5.1, 5.1, 4.1, 7.1), xpd=TRUE)
legend("topleft",  
     axislabels2, fill=brewer.pal(6, "Set3"), bty="n", ncol=2,text.width=5)
axis(side=1, at=c(5,12,18), labels=c( "Pj", "F", "Pa"), line=1, tick=FALSE)

@


\end{document}
