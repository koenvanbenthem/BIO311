\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage{bbold}
\usepackage{tikz}
%\usepackage{silence}
\usepackage{mdframed}
%\WarningFilter{mdframed}{You got a bad break}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{color}
\colorlet{exampcol}{blue!10}
\usepackage{multicol}
\usepackage[answerdelayed]{exercise}
\usepackage{booktabs}
\usepackage{caption}

\title{BIO311: Population Ecology\\ \textit{Prac 8: Life tables \& Population Matrices}}

\setcounter{tocdepth}{1} % Determines the depth of the table of contents;; 0:chapters, 1: chapters and sections, 2: chapters,sections and subsections

%\renewcommand{\theExercise}{\thechapter.\arabic{Exercise}}%

\begin{document}
\input{../authors}
<<setup, cache=FALSE, include=FALSE>>=
opts_chunk$set(dev="pdf",tidy=F,dev.args=list(pointsize=7.5))
options(width=60)

@

<<setparameters,echo=FALSE,include=FALSE>>=

@
\maketitle
\tableofcontents
\vspace{3cm}
\newpage
\section{Hypothetical Dataset}
\subsection{Life table}
In this practical, you will work with life tables. Read the following text carefullyand do the exercise at the end of this section. The first part is the description of a hypothetical barn owl population and the second part is brief reminder of life table theory. 

\begin{figure}[h]
\centering
\includegraphics[width=0.3\textwidth]{Barnowl.jpg}
\caption{\label{fig:owl}Barn owl, from wikipedia.}
\end{figure}

\subsubsection{A barn owl population}
The barn owl (Schleiereule in German) is a common noctural prey bird (see fig. \ref{fig:owl}). We focus on a cohort of female barn owls that were born in 2010 and who have all died by the beginning of 2014.
\begin{itemize}
\item In 2010, 10 female chicks were born and were followed over the years. 
\item In 2011, 8 of them were still alive. Only 4 females of this cohort reproduced in 2011: two produced 4 female chicks, one produced 3 female chicks and the last one produced 5 female chicks. 
\item In 2012 only 4 females were still alive. This time, they each produce 3 female chicks. 
\item In 2013, only one individual of the original cohort was still alive and had only one female chick. 
\item In 2014, all individuals were dead.
\end{itemize}


\subsubsection{Standard cohort life table}

\begin{table}[h]
\centering
\caption{\label{tab:LT}An example of a life table.}
\begin{tabular}{ccccccc}
$x$ & $S(x)$ & $b(x)$ & $l(x)$ & $g(x)$ & Rep. rate \\\hline
$0$ &  $10$ & ... & ... & ...&...\\
$1$ & $8$ & ... & ... & ...&...\\
$2$ & ... & ... & ... & ...&...\\
$3$ & ... & ... & ... & ...&...\\
$4$ & ... & ... & ... & ...&...\\
\end{tabular}
\end{table}

Table \ref{tab:LT} contains the standard life-table calculation. Below is a description of each column. We purposefully do not provide you with the equations to obtain each value, we left this for you to find out. 
\begin{itemize}

\item \textit{The first column} $x$ is the age of the individuals. By convention, the newborn start at age $0$ and are age $1$ at their first birthday. 

\item \textit{The second column} $S(x)$ is the number of individuals of the cohort still alive at age $x$. 

\item \textit{The third column} $b(x)$ is the fecundity schedule (sometimes it is refered to as $m(x)$, \textit{m} for maternity). It is the \textbf{average number of female offspring born per unit of time to a female of a given age}. 

\item \textit{The fourth column} $l(x)$ is the survivorship schedule, not to be confused with the survival probability $g(x)$. It is defined as the \textbf{proportion of the original cohort that survives to a given age}. Or in other words it is the probability that an individual survives from birth to age $x$. 

\item \textit{The fifth column} $g(x)$ is the survival probability. It is different from the survivorship schedule in that it is the \textbf{probability that an individual of age $x$ survives to age $x+1$}. 

\item \textit{The sixth column} Rep. rate is what we call the reproductive rate: what is the mean number of offspring that each individual produce at a given age, regardless of whether the individual survives until that age. We are in fact interested in the \textbf{net reproductive rate, $R_0$} but to find it, we must first find the reproductive rate of each age. The net reproductive rate is defined as the \textbf{mean number of female offspring produced per female individual over their lifetime.} It is the reproductie potential of a female corrected for its mortality.
\end{itemize}

In addition to the elements of the table, there a few more important properties you can extract from the life table. A general property of the table is, $G$, the generation time. A definition of the generation time is \textbf{the average age of mothers when they give birth}. From the life table, you can also calculate the instantaneous rate of increase, $r$. Remember from Arpat's lecture on unstructured population that:
\begin{equation}
N_t=N_0e^{rt}
\end{equation}
The exact solution of $r$ is given by solving the following equation adapted from the Lotka-Euler equation for $r$:
\begin{equation}
1=\sum\limits_{x=0}^k e^{-rx}l(x)b(x)
\end{equation}
This equation can only be solved iteratively. Alternatively, an approximation of $r$ is given by:
\begin{equation}
r \approx \frac{\ln(R_0)}{G}
\end{equation}


\begin{Exercise}[title=Life Table, label=LT, difficulty=1]
Write on paper a life table for the hypothetical barn howl population described above. Your life table should be organised like table \ref{tab:LT} and contain the same columns. For each column, write the corresponding equation. 

In addition, find $R_0$, $G$ and the approximation of $r$.
\end{Exercise}
\begin{Answer}[ref=LT]
The column $x$ and $S(x)$ are directly given in the text. 
\begin{equation}
b(x)=\frac{n(x)}{S(x)}
\end{equation}
where $n(x)$ is the number of female offspring produced by all the females of age $x$. $n(x)=\sum\limits_{i=1}^k{n(i)}$, where $n(i)$ is the number of female offspring per female of age $x$ in the cohort and $k$ the number of female age $x$ in the cohort.

\begin{equation}
l(x)=\frac{S(x)}{S(0)}
\end{equation}

\begin{equation}
g(x)=\frac{S(x+1)}{S(x)}
\end{equation}

\begin{equation}
Rep. rate=l(x)b(x)
\end{equation}
\begin{equation}
R_0=\sum\limits_{x=0}^k{l(x)b(x)}
\end{equation}
where $k$ is the maximum age. 

\begin{equation}
G=\frac{\sum\limits_{x=0}^k{l(x)b(x)x}}{\sum\limits_{x=0}^k{l(x)b(x)}}
\end{equation}
It may therefore be interesting to add an additional column to the table:
\begin{equation}
l(x)b(x)x=l(x)b(x)x
\end{equation}
<<t1,echo=F,eval=T,results='asis', warning=FALSE>>=
library(xtable)

#The age 
x<- c(0,1,2,3,4)
#The survivors
S<-c(10,8,4,1,0)
#The fecundtity schedule
b<-c(0,2,3,1,0)
#The survivorship Schedule
l<-S/S[1]
#The survival probability
g<-append(S[c(2:5)]/S[c(1:4)],NA)
#The reproductive rate
Rep_rat<-l*b
#l(x)b(x)x
lbx<-l*b*x


lt<-data.frame(x,S,b,l,g,Rep_rat, lbx)

print(xtable(lt, digits=2), 
      size="footnotesize", #Change size; useful for bigger tables
      include.rownames=FALSE, #Don't print rownames
      include.colnames=FALSE, #We create them ourselves
      floating=FALSE,
      hline.after=NULL, #We don't need hline; we use booktabs
      add.to.row = list(pos = list(-1, 
                                   nrow(lt)),
                        command = c(paste("\\toprule \n",
                                          "$x$ & $S(x)$ & $b(x)$ & $l(x)$ & $g(x)$ & Rep. rate & $l(x)b(x)x$ \\\\\n", 
                                          "\\midrule \n"),
                                    "\\bottomrule \n")
                        ))
@

<<t01,echo=F,eval=T,results='asis'>>=
#The net reproductive rate
R0<-sum(Rep_rat)
cat("\\noindent")
cat("$R_0=$",R0,"\\\\")
#The generation time
G<-(sum(l*b*x))/(sum(l*b))
cat("$G=$",G,"\\\\")
#estimated r
r<-log(R0)/G
cat("$r=$",r,"\\\\")

@

\end{Answer}


\subsection{Age-structured Matrix Analysis}
In the former section, we have followed the fate of a hypothetical cohort of barn owls. Let us now look at the transition matrix. We want to know the number of individuals in each age class. Imagine these $10$ female barn owls are the founders of a new population and we do a postbreeding census, in which females are counted each year just after they have bred. 
\begin{itemize}
\item In $2010$, there are $10$ females in age class $1$. 
\item In $2011$ there are $8$ in  females in age class $2$ and $16$ females in age class $1$.  
\item In $2012$ there are $4$ females in age class $3$, $13$ females in age class $2$ and $12$ females produced by the individuals in age class $2$ and $26$ females produced by the females in age class $1$. 
\item In $2013$ there is $1$ female in age class $4$, $7$ in age class $3$ and $30$ in age class $2$. There are in addition $81$ new individuals in age class $1$: $1$ from the females in age class $3$, $19$ from the females in age class $2$ and $61$ from the females in age class $1$. The survival rate of the age class 4 is $0$.
\end{itemize}
\begin{Exercise}[title=Age-structured matrix, label=ASM, difficulty=1]
\Question Let us work out the matrix of this barn owl population on paper.
\subQuestion First, draw the life cycle of the population of barn owls describe above.
\subQuestion Find the survival probability $P_i$ for each age class $i$, that is the probability of an individual in age class $i$ to age class $i+1$. 
\subQuestion Find the fertility $F_i$, the average number of offpsring produced by an individual of age class $i$.
\subQuestion Write the equations to get the number of individuals in each age class at time $t+1$. Your equations should be of the form $n_1(t+1)=F_1n_1(t)$.
\subQuestion What is the structure of the corresponding Leslie matrix? What is the dimension of your matrix?
\subQuestion Build the corresponding Leslie matrix of this population.
\end{Exercise}
\begin{Answer}[ref=ASM]
\Question 
\subQuestion
\begin{center}
\includegraphics[width=0.95\textwidth]{Barn_owl_life_cycle.pdf}
\end{center}
\subQuestion  
<<tA1,echo=T,eval=T,results='asis'>>=
#Finding the survival rate of age class 1   
age1<-c(10, 16, 38) #individuals in age class 1 
                    # in time t
age2<-c(8, 13, 30) #individuals in age class 2 
                #in time t+1 (i.e. the sruviving
              #individuals from age class 1 in t)

p1<-age2/age1 #yearly survival rate

P1<-mean(p1) # mean of survival rate
                   #of age class 1, P1

#Finding the survival rate of age class 2   
  age2<-c(8, 13) #individuals in age class 2 
                 #in time t
  age3<-c(4, 7) #individuals in age class 3
                # in time t+1  

p2<-age3/age2 #yearly fertility rate

P2<-mean(p2) #yearly survival rate

#Finding the survival rate of age class 3 
P3 <- 1/4     #individuals in age class 4
              # in time t+1 over the number
              #of individuals in age class
            #3 in time t

#Finding the survival rate of age class 4 
P4 <- 0
@
\subQuestion 
<<tA2,echo=T,eval=T,results='asis'>>=
#Finding the contribution of age class 1 
#to the next generation  
 
age1<-c(10, 16, 38) #individuals in age class 1 
                    # in time t
offa1<-c(16, 26, 61) #offspring in time t+1 
                     #produced by age class 1 

f1<-offa1/age1 #yearly fertility rate

F1<-mean(f1) #mean of fertility, F1

#Finding the contribution of age class 2 to 
#the next generation  
  age2<-c(8, 13) #individuals in age class 2 
                 # in time t
  offa2<-c(12, 19) #offspring in time t+1 
                  #produced by age class 2 

f2<-offa2/age2 #yearly fertility rate

F2<-mean(f2) #mean of fertility, F2

#Finding the contribution of age class 3 to
#the next generation  
F3 <- 1/4 #offspring in t+1 produced by individuals
          #in age class 3 at t

#F4 is zero
F4<-0
@
\subQuestion 
\begin{eqnarray}
n_1(t+1)&=&F_1 n_1(t)+F_2 n_2(t)+F_3 n_3(t)+F_4 n_4(t)\\
n_2(t+1)&=&P_1 n_1(t)\\
n_3(t+1)&=&P_2 n_2(t)\\
n_4(t+1)&=&P_3 n_3(t)
\end{eqnarray}
\subQuestion 
\begin{equation}
\begin{pmatrix}
F1&F2&F3&F4\\
P1&0&0&0\\
0&P2&0&0\\
0&0&P3&P4
\end{pmatrix}
\end{equation}
\subQuestion 
\begin{equation}
\begin{pmatrix}
\Sexpr{round(F1,2)}&\Sexpr{round(F2,2)}&\Sexpr{round(F3,2)}&\Sexpr{round(F4,2)} \\
\Sexpr{round(P1,2)}&0&0&0\\
0&\Sexpr{round(P2,2)}&0&0\\
0&0&\Sexpr{round(P3,2)}&\Sexpr{round(P4,2)}
\end{pmatrix}
\end{equation}

\end{Answer}

\subsubsection{Matrices in \texttt{R}}
Now that you have found the matrix of this population, let us implement it in \texttt{R}. Set the initial population vector to the founder population ($10$ individuals in age class $1$). 

<<t2a,echo=F,eval=T, results='hide'>>=
# Build the Leslie Matrix for the barn owl population

F1<- 1.61
F2<- 1.48
F3<- 0.25
F4<- 0

P1<- 0.80
P2<- 0.52
P3<- 0.25
P4<- 0 
  
A<-matrix(c(F1, P1, 0, 0, F2, 0, P2, 0, F3, 0, 0, P3, F4,0,0,P4), nr=4)
A
# The initial population vector

n11<- 10
n12<- 0
n13<- 0
n14<- 0
  
n0<-c(n11, n12, n13, n14)  
@

<<t2b,echo=T,eval=F>>=
# Build the Leslie Matrix for the barn owl population

F1<- #insert your value here
F2<- #insert your value here
F3<- #insert your value here
F4<- #insert your value here

P1<- #insert your value here
P2<- #insert your value here
P3<- #insert your value here
P4<- #insert your value here 
  
A<-matrix(c(F1,P1,0,0,F2,0,P2,0,F3,0,0,P3,F4,0,0,P4), 
          nrow=4,byrow=FALSE)
A
# The initial population vector

n11<- #insert your value here
n12<- #insert your value here
n13<- #insert your value here
n14<- #insert your value here
  
n0<-c(n11, n12, n13, n14)  
@
What happens if you set \texttt{byrow=TRUE} instead?

The next step is to project the population in the future. We have seen in the lecture that
\begin{equation}
\vec{n}(t+1)=\boldsymbol{A}\vec{n}(t)
\end{equation}
To do so, we write the two following functions in \texttt{R}. The sign \%*\% is for matrix multiplication in \texttt{R}.
<<t2,echo=T,eval=F>>=
n1<-n0%*%A
nt2<-A%*%n0
@
Try to run both lines. One is incorrect, which one and why?

Next let us use this matrix to project the population. To do so we use a \texttt{for} loop over a specified time span. We first need to build an empty array with the \texttt{matrix} function where we store the data that we calculate during the loop. We call this array \texttt{n}, it is an array that has the same number of rows that the matrix $\boldsymbol{A}$ and has as many column as the time span we set. Thus each column corresponds to one year. \texttt{n} will look like this:
\begin{equation*}
\begin{pmatrix}
N_{age=1,t=1} & N_{age=1,t=2} & N_{age=1,t=3} & \dots & N_{age=1,t=T} \\
N_{age=2,t=1} & N_{age=2,t=2} & N_{age=2,t=3} & \dots & N_{age=2,t=T}\\
N_{age=3,t=1} & N_{age=3,t=2} & N_{age=3,t=3} & \dots & N_{age=3,t=T}\\
N_{age=4,t=1} & N_{age=4,t=2} & N_{age=4,t=3} & \dots & N_{age=4,t=T}\\
\end{pmatrix}
\end{equation*}
By first setting the time span to $4$, check if we get the same population as the one described in the text. Then try different values of time span. To access column \texttt{5} of this matrix, you can type \texttt{n[,5]}. Also in \texttt{R} the first index specifies the row number and the second one the column number. Because we want to see all rows at the same time, we leave out an index for the row. (\texttt{n[3,5]} would for example only give the entry for age class 3 at time 5.)

Complete the following code to calculate how the population develops over time
<<t3b,echo=T,eval=F>>=
tspan <- ... #insert value for time span 
rows <- ... # insert number of rows

# Build some matrices for storing eventual output
n <- matrix(0,nrow=rows,ncol=tspan)     # empty matrix 

n[,1] <- c(...,...,...,...)           # insert value for the initial 
                              # population in each age class

# Project population forward and store output
for (t in ...){
    n[,t] <- .....    # %*% = matrix multiplication in R
                                    
}

@

The sum of each column is the total population size. We can then plot it.

<<t4,echo=T,eval=F>>=
Ntot<-colSums(n) # This calculates the sum 
                 # of all the age classes per time step
plot(Ntot, type="l", xlab="year", ylab="N(t)")

@

How does the population behave?

\subsubsection{Asymptotic behaviour}
\textit{Asymptotic rate of increase} 

From the matrix, we can find the asymptotic growth rate of that population. For this we need to look at the dominant eigenvalue of the population matrix. Remember from the lecture that the dominant eigenvalue of a population matrix is the long term asymptotic rate of increase, $\lambda$. An eigenvalue of a matrix is a \textbf{scalar that when multiplied by a specific vector, gives the same result as when that vector is multiplied by ththe concerning matrix}. Mathematically this means:
\begin{equation}\label{eig}
\boldsymbol{A} \vec{v}=\lambda \vec{v}
\end{equation}
the vector $\vec{v}$ is not any vector but an eigenvector, that is a vector such that equation \ref{eig} holds. We will come back to it later. If you do not feel comfortable with the concept of eigenvectors/matrices, you might want to return to the last two exercises of the mathematical tools script.

In \texttt{R} we do not have to just see the eigenvectors, instead they can be found using the \texttt{eigen()} function.
<<t6,echo=T,eval=T, results='hide'>>=
eigens.A<-eigen(A)
eigens.A
@

Let us focus at the moment only on the first values. The first values returned by the function; \Sexpr{round(eigens.A$values,3)} are the eigenvalues of the matrix $\boldsymbol{A}$. A matrix has as many eigenvalues as it has dimensions. The only one we are interested in for now is the dominant eigenvalue, i.e. the largest eigenvalue. From looking at the eigenvalues, we can see that it is the first one. However, the dominant eigenvalue can be found by using the function \texttt{which.max()} that returns the position of the maximum value of the object. Then we extract the value in that position.
<<t7,echo=T,eval=T, results='hide'>>=
position <- which.max(eigens.A$values)
position

lambda2<-eigens.A$values[position]
lambda2
@
Alternatively, $\lambda$ can be found directly from the \texttt{lambda} funtion of the \texttt{popbio} package in \texttt{R}, which will give you exactly the same result. 
<<t8,echo=T,eval=T>>=
library(popbio)
lambda(A)
@
What does this value of $\lambda$ mean for the population on the long term?
\vspace{0.5 cm}

\noindent\textit{Stable-age distribution} 

In the previous section, we looked at the growth of the whole population. It is also informative to examine what the population structure will look like on the long-term. We already calculated these numbers before, let us now plot them. 
<<t10,echo=T,eval=F>>=

plot(log(n[1,]), type="l", col="blue", ylim=c(0,5),
     xlab="year", ylab="ln(n(t))") 
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topright",
       c("age class 1 ","age class 2", "age class 3", 
         "age class 4"), 
       bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))
@ 

<<t3a,echo=F,eval=T>>=
tspan <- 10                         # time span for projections
rows <- dim(A)[1]

# Build some matrices for storing eventual output
n <- matrix(0,rows,tspan)     # storage of age-specific abundance

n[,1] <- c(10 ,0,0,0)              # initial population abundance in each age class

# Project population forward and store output; note that
# %*% in R implies matrix multiplication, and * implies scalar multiplication
# or element-by-element multiplication of matrix entries.
for (t in 1:(tspan-1)) {
    n[,t+1] <-A%*% n[,t]      # %*% = matrix multiplication in R
                                  
}
Ntot<-colSums (n)
par(mar=c(6,6,2,2))
plot(log(n[1,]), type="l", col="blue", ylim=c(0,10), xlab="year", ylab="$\\ln(n(t))$") #please add slash!
lines(log(n[2,]), col="red")
lines(log(n[3,]), col="green")
lines(log(n[4,]), col="purple")
legend("topleft",
       c("age class 1 ","age class 2", "age class 3", "age class 4"), 
       bty = "n",
lty=c(1,1,1,1),
col=c("blue", "red", "green", "purple"))


@ 
When reading the graph, keep in mind that the $y$-axis is logarithmic. We see that after five years, the age class trajectories are parallel to each other and growing with a constant rate. If a population is growing with constant birth and death rate, as is the case of our owl population, then the population converges to a stable age distribution. Once a population has reached the stable age distribution, it grows exponentially at the asymptotic finite rate. A population at the stable age distribution always has the same relative number of individuals in each age class every time step. However, the absolute number of indiviuals will change. The stationary age distribution is a special case of stable age distribution where the absolute number of individuals does neither increase nor decrease. The population is not growing. What is the asymptotic growth rate ($\lambda$) of such a stationary population? 


The stable age distibution is given by the right eigenvector corresponding to the dominant eigenvalue. Let us now look at the vector elements of the \texttt{eigen} function. The columns of \texttt{eigens.A\$vector} are the right eigenvectors of the matrix $\boldsymbol{A}$. When applying the matrix to them, it is the same as multiplying them by the corresponding eigenvalues, which are scalars. This means that the length but not the direction of this vector is changed by the matrix. Check this for the eigenvector corresponding to the dominant eigenvalue.

There are as many right eigenvectors as there are eigenvalues. To each eigenvalue one eigenvector corresponds. Its position is the same as the one of the dominant eigenvalue so we can extract it with the following lines of code.

<<t11,echo=T,eval=T, results='hide'>>=
w<-eigens.A$vector[,position]
w
@
The right eigenvector as such does not give us the proportion found in each age class. This is because the length of the vector is set to $1$ instead of the sum of its elements (what is the difference between these two? Which is biologically more relevant? Which is mathematically more relevant?). However, to find the proportion of each age class, we want to rescale it (remember that if you find an eigenvector all vectors that point in the same direction are also eigenvectors. If we multiply an eigenvector by a scalar it thus remains an eigenvector.):
<<t12,echo=T,eval=T, results='hide'>>=
ssd<-w/sum(w)
ssd
@
Therefore we know now that a proportion of \Sexpr{round(ssd[1],2)} of the population is in age class 1, \Sexpr{round(ssd[2],2)} in age class 2, \Sexpr{round(ssd[3],2)} in age class 3, and \Sexpr{round(ssd[4],2)} in age class 4.

\subsubsection{Sensitivity and elasticity analysis}
\noindent\textit{Sensitivity analysis} 
Sensitivities and elasticities of $\lambda$ evaluate the relative importance of each matrix element for the asymptotic growth rate. Sensitivity is the effect of additive change in a matrix element on $\lambda$ and the elasticity is the proportional effect of a proportional change in the parameter to $\lambda$.

The sensitivity tells us how an increase in absolute value of one of the parameters affects $\lambda$. How much does $\lambda$ increase if the fertility of the age class 1 increases by a very small amount (for example 0.01)? Let us play around with the projection matrix and change each element of this matrix by 0.01 one by one to see how if affects $\lambda$. 
<<t13,echo=T,eval=F>>=
# Build the Leslie Matrix for the barn owl population

F11<-    + 0.01 #insert your value here
F21<- #insert your value here
F31<- #insert your value here
F41<- #insert your value here

P11<- #insert your value here
P21<- #insert your value here
P31<- #insert your value here
P41<- #insert your value here 
  
A1<-matrix(c(F11,P11,0,0,F21,0,P21,0,F31,0,0,P31,F41,0,0,P41), nr=4)
A1
lambdaF1<- lambda(A1)
@

The sensitivity of $\lambda$ to one element of the matrix is given by:
\begin{equation}
s_{ij}=\frac{\partial \lambda} {\partial a_{ij}}
\end{equation}
So the sensitivity can be approximated by taking the difference between the value of $\lambda$ \; of the original matrix and the modified matrix and dividing it by the change we apply to the element of the matrix. 
\begin{itemize}
\item $\partial \lambda$ \; can be approximated by the difference between the original $\lambda$ \; and the new $\lambda$.
\item $\partial a_{ij}$ can be approximated by the difference between the original $a_{ij}$ and the new $a_{ij}$  
\end{itemize}
If the change to the element of the matrix is very small, the sensitivities calucated so will be close from the actual sensitivities. If you want to calculate all sensitivities using this approximation, it is probably best to use a \texttt{for} loop (or actually two, why two?). Do not forget to only change one matrix element at a time. Also investigate how small the change in the matrix element has to be to make sure that the approximation returns reasonable numbers.

\begin{Exercise}[title=Sensitivities, label=SENSI, difficulty=1]
\Question Calculate (by actually changing elements in the matrix one by one in \texttt{R}) the sensitivity of $\lambda$ to each matrix element. \textit{Hint: use a for loop}.
\Question How much would the population rate change if you would increase the rate at location \texttt{[3,1]} with a value of 0.1? Would you consider trying adapting this rate a good management strategy?
\end{Exercise}
\begin{Answer}[ref=SENSI]
\Question The exact values are:
<<t14,echo=F,eval=T, results='asis'>>=
sen<- sensitivity(A)

print(xtable(sen, digits=4),
      size="footnotesize", #Change size; useful for bigger tables
      include.rownames=FALSE, #Don't print rownames
      include.colnames=FALSE, #We create them ourselves
      floating=FALSE,
      hline.after=NULL, #We don't need hline; we use booktabs
      add.to.row = list(pos = list(-1, 
                                   nrow(sen)),
                        command = c(paste("\n",
                                          "$n_1$ & $n_2$ & $n_3$ & $n_4$ \\\\\n",
                                          "\n"),
                                    "\n")
                        )
      )
@
see how your approximation will get closer to this value as you decrease the magnitude of the perturbation.
\Question The sensitivity of this element is \Sexpr{sensitivity(A)[3,1]}, if we increase the matrix element by $0.1$, we would thus get an increase in lambda of $0.1\cdot \Sexpr{sensitivity(A)[3,1]} = \Sexpr{0.1*sensitivity(A)[3,1]}$. This does increase $\lambda$, however, in reality we won't be able to increase this rate: how do we biologically try to increase the rate with which owls go from age 1 to age 3 within one year? It is important with sensitivity analysis to realize that not all sensitivities make sense in the biological world.
\end{Answer}


\vspace{1.5ex}
\noindent\textit{Elasitcity analysis}
Elasticities are proportional sensitivities. Before we asked the question: if a matrix element increases by a small amount, how much does $\lambda$ \; increase? Elasticities ask a different question: with what factor does $\lambda$\; change if a matrix element is changed by a certain factor. They thus examine the effect of a proportional change of transition elements on $\lambda$. For example, you may be interested in knowing by how much does $\lambda$\; change if the fertility of age class 2 is increased by 25\%. 
 
The elasticity of $\lambda$\; to a proporitonal change of one element of the matrix is given by:
\begin{equation}
e_{ij}=\frac{a_{ij}}{\lambda} \frac{\partial \lambda} {\partial a_{ij}}
\end{equation}
\begin{Exercise}[title=Elasticities, label=ELASI, difficulty=1]
\Question Calculate the elasticities from the sensitivities that you found in the previous exercise
\Question What is now the prediction for the effect of changing element \texttt{[3,1]}?
\end{Exercise}
\begin{Answer}[ref=ELASI]
\Question Here we show the exact elasticity values. Make sure that your values (from the approximation) are close to these

<<t15,echo=F,eval=T, results='asis'>>=
ela<- elasticity(A)
print(xtable(ela, digits=4), 
      size="footnotesize", #Change size; useful for bigger tables
      include.rownames=FALSE, #Don't print rownames
      include.colnames=FALSE, #We create them ourselves
      floating=FALSE,
      hline.after=NULL, #We don't need hline; we use booktabs
      add.to.row = list(pos = list(-1, 
                                   nrow(ela)),
                        command = c(paste("\n",
                                          "$n_1$ & $n_2$ & $n_3$ & $n_4$ \\\\\n",
                                          "\n"),
                                    "\n")
                        )
      )
@
\Question Elasticities are always $0$ for matrix elements that are $0$, therefore, elasticities will predict that changing element \texttt{[3,1]} will not influence the population dynamics.
\end{Answer}


\subsubsection{Transient dynamics}
Most of what we have described above focuses on the asymptotic, (i.e. long-term) behaviour of the system. However, the short-term dynamics can be very different. In nature, a population may never be observed in the asymptotic regime. Transient dynamics focuses on short-term responses.   

There are year-to-year variations in growth rate before the asymptote is reached. The code below calculate the annual finite growth rates of the barn owl population. 
<<t16,echo=T,eval=T, results='hide'>>=
Ntot # the total population size vector.
     # Each element is the population size
     # at one time step. As calculated before
Ntott<-Ntot[2:(length(Ntot)+1)]
# the total popoluation size at t+1

R<-Ntott/Ntot
# the annual finite growth rates
#vector

@

We can plot this in a graph to see how much time it takes this population to reach the asymptotic finite  growth rate. For this we first create a vector of the same length as the annual growth rate vector in which all elements contain the value of $\lambda$.

<<t17,echo=T,eval=T, results='asis'>>=
lam<-lambda(A)

plot(R, type="l", col="blue", xlab="year", ylab="growth rate") 
abline(h=lam, col="red")
legend("topright",
       c("annual growth rate","asymptotic growth rate"), 
       bty = "n",
lty=c(1,1),
col=c("blue", "red"))


@
It thus takes around five years before the population reaches its asymptotic growth rate.

\subsection{Eigenvector decomposition}

\begin{Exercise}[title=Eigenvector decomposition, label=ED, difficulty=2]
\Question 
We consider a population that consists of only two classes: juveniles and adults. After one time step, 60\% of the juveniles stay juveniles, 20\% become adults and the remaining 20\% dies. The adults have a 80\% chance of survival and produce 0.5 juveniles on average. We thus have the following matrix:
\begin{equation}
\boldsymbol{A} = \begin{pmatrix} 0.6 & 0.5 \\ 0.2 & 0.8 \end{pmatrix}
\end{equation}
<<matje,echo=FALSE,include=FALSE>>=
A <- matrix(c(0.6,0.5,0.2,0.8),ncol=2,byrow=TRUE)
eigen(A)
A
n <- c(5,2)
v1<- -eigen(A)$vectors[,1]
v2<- -eigen(A)$vectors[,2]
lambda1 <- eigen(A)$values[1]
lambda2 <- eigen(A)$values[2]
c11<-(n%*%v1)/(0.2*(v1*n%*%v1 + v2*n%*%v2)[1]) 
c22<-(n%*%v2)/(0.2*(v1*n%*%v1 + v2*n%*%v2)[1])
A %*% A %*% n
@

Now consider the following population:
\begin{equation}
\vec{n}(0) = \begin{pmatrix} \Sexpr{n[1]}\\ \Sexpr{n[2]} \end{pmatrix}
\end{equation}

\subQuestion Calculate $\vec{n}(1)$ up to $\vec{n}(4)$. \\

We are now going to try and find a more direct way to find $\vec{n}(t)$. For this, we realize that we can write $\vec{n}(0)$ as a combination of the two eigenvectors:
\begin{equation}
\vec{n}(0) = c_1 \vec{v}_1 + c_2 \vec{v}_2
\end{equation}

We can now obtain the eigenvalues and eigenvectors of this matrix:
\begin{equation}
\lambda_1 = \Sexpr{round(eigen(A)$values[1],2)},\; \lambda_2 = \Sexpr{round(eigen(A)$values[2],2)}
\end{equation}
\begin{equation}
\vec{v}_1 = \begin{pmatrix}\Sexpr{round(v1[1],2)}\\ \Sexpr{round(v1[2],2)}\end{pmatrix},\vec{v}_2 = \begin{pmatrix}\Sexpr{round(v2[1],2)}\\ \Sexpr{round(v2[2],2)}\end{pmatrix}\;
\end{equation}


\subQuestion Calculate $c_1$ and $c_2$.
Now we use this notation, to find an expression for $\vec{n}(t)$. Let us first find a notation for $\vec{n}(1)$:
\begin{equation}
\vec{n}(1) = \boldsymbol{A} \vec{n}(0) = \boldsymbol{A} \left( c_1 \vec{v}_1 + c_2 \vec{v}_2\right) = c_1 \boldsymbol{A} \vec{v}_1 + c_2 \boldsymbol{A} \vec{v_2}
\end{equation}
\subQuestion Use the properties of eigenvectors to rewrite the right side of the above equation into a form that does not contain $\boldsymbol{A}$ anymore, and instead contains $\lambda$.
\subQuestion Using the same notation, what is the value of $\vec{n}(2)$?
\subQuestion And $\vec{n}(t)$? Verify this answer by calculating $\vec{n}(1)$ up to $\vec{n}(4)$ using the equation you found.
\subQuestion If $t\rightarrow \infty$, a stable stage distribution is reached. What does this distribution look like? How can you see that from your answer to the previous question?
\subQuestion How much does the population grow at this point? Is this a stable population?
\end{Exercise}

\begin{Answer}[ref=ED]
\Question
\subQuestion

<<matje_ans,results='asis',echo=FALSE>>=

for(t in 1:4){
  tmp <- n

  for(t2 in 1:t){
    tmp <- A%*%tmp
  }
   cat("$\\vec{n}(",t,") = \\begin{pmatrix}", round(tmp[1],1),"\\\\", round(tmp[2],1),"\\end{pmatrix} $")
  if(t < 4) cat("$, \\; \\;$")
}

@

\subQuestion We try to find $c_1$ and $c_2$, such that:
\begin{equation*}
\vec{n}(0) = c_1 \vec{v}_1 + c_2 \vec{v}_2 =  c_1 \begin{pmatrix}\Sexpr{round(v1[1],2)}\\ \Sexpr{round(v1[2],2)}\end{pmatrix} + c_2 \begin{pmatrix}\Sexpr{round(v2[1],2)}\\ \Sexpr{round(v2[2],2)}\end{pmatrix} 
\end{equation*}
and we know that:
\begin{equation*}
\vec{n}(0) = \begin{pmatrix} \Sexpr{n[1]} \\ \Sexpr{n[2]} \end{pmatrix}
\end{equation*}
And thus:
\begin{equation*}
c_1 \begin{pmatrix}
\Sexpr{round(v1[1],2)} \\ 
\Sexpr{round(v1[2],2)}
\end{pmatrix} + 
c_2 \begin{pmatrix}
\Sexpr{round(v2[1],2)}\\ 
\Sexpr{round(v2[2],2)}
\end{pmatrix} =  
\begin{pmatrix} \Sexpr{n[1]} \\ \Sexpr{n[2]} \end{pmatrix}
\end{equation*}
We write the expression on the left side out:
\begin{equation*}
\begin{pmatrix} c_1 \cdot \Sexpr{round(v1[1],2)}\\ c_1 \cdot \Sexpr{round(v1[2],2)}\end{pmatrix} + \begin{pmatrix}c_2 \cdot \Sexpr{round(v2[1],2)}\\ c_2 \cdot \Sexpr{round(v2[2],2)}\end{pmatrix} =  \begin{pmatrix} \Sexpr{n[1]} \\ \Sexpr{n[2]} \end{pmatrix}
\end{equation*}
We can now write this as two separate equations:
\begin{equation} \label{sol1}
\Sexpr{round(v1[1],2)} \cdot c_1 + \Sexpr{round(v2[1],2)} \cdot c_2  = \Sexpr{n[1]} \tag{$\clubsuit$}
\end{equation}
\begin{equation} \label{sol2}
\Sexpr{round(v1[2],2)} \cdot c_1 \Sexpr{round(v2[2],2)} \cdot c_2 = \Sexpr{n[2]} \tag{$\diamondsuit$}
\end{equation}
From the first of these two equations (\ref{sol1}), we can find that:
\begin{equation*}
\Sexpr{round(v1[1],2)} \cdot c_1 = \Sexpr{n[1]} - \Sexpr{round(v2[1],2)} \cdot c_2
\end{equation*}
And thus:
\begin{equation*} \label{sol3}
c_1 = \frac{\Sexpr{n[1]} - \Sexpr{round(v2[1],2)} \cdot c_2}{\Sexpr{round(v1[1],2)}} = \Sexpr{round(n[1]/(v1[1]),2)} - \Sexpr{round(v2[1]/(-eigen(A)$vectors[1,1]),2)} \cdot c_2 \tag{$\spadesuit$}
\end{equation*}
We use this in the second equation (\ref{sol2}):
\begin{equation*} 
\Sexpr{round(v1[2],2)} \cdot c_1 \Sexpr{round(v2[2],2)} \cdot c_2 = \Sexpr{n[2]}
\end{equation*}
This equation now becomes:
\begin{equation*}
\Sexpr{round(v1[2],2)} \cdot \left(\Sexpr{round(n[1]/(v1[1]),2)} - \Sexpr{round(v2[1]/(v1[1]),2)} \cdot c_2\right) \Sexpr{round(v2[2],2)} \cdot c_2 = \Sexpr{n[2]}
\end{equation*}
This can be simplified to:
\begin{equation*}
\Sexpr{round(v1[2]*n[1]/(v1[1]),2)} \Sexpr{round(-v1[2]*v2[1]/(v1[1])+v2[2],2)} \cdot c_2 = \Sexpr{n[2]}
\end{equation*}
Now we find that:
\begin{equation*}
\Sexpr{round(v1[2]*v2[1]/(v1[1])-v2[2],2)} \cdot c_2 = \Sexpr{round(v1[2]*n[1]/(v1[1])-n[2],2)}
\end{equation*}
And thus:
\begin{equation*}
c_2 = \Sexpr{round((v1[2]*n[1]/(v1[1])-n[2])/(v1[2]*v2[1]/(v1[1])-v2[2]),2)}
\end{equation*}
<<setc2,include=FALSE>>=
c2 <- (v1[2]*n[1]/(v1[1])-n[2])/(v1[2]*v2[1]/(v1[1])-v2[2])
@
Now, using equation \ref{sol3}, we can easily calculate $c_1$:
\begin{equation*} 
c_1 = \Sexpr{round(n[1]/(v1[1]),2)} - \Sexpr{round(v2[1]/v1[1],2)} \cdot c_2 = \Sexpr{round(n[1]/v1[1] - c2*v2[1]/v1[1],2)}
\end{equation*}
<<setc1,include=FALSE>>=
c1 <- n[1]/v1[1] - c2*v2[1]/v1[1]
@
Now we can check if these two factors are correct:
\begin{equation*}
\Sexpr{round(c1,2)} \cdot \begin{pmatrix} \Sexpr{round(v1[1],2)} \\ \Sexpr{round(v1[2],2)} \end{pmatrix} + \Sexpr{round(c2,2)} \cdot \begin{pmatrix} \Sexpr{round(v2[1],2)} \\ \Sexpr{round(v2[2],2)} \end{pmatrix} = \begin{pmatrix} \Sexpr{(c1 * v1 + c2 * v2)[1]} \\ \Sexpr{(c1 * v1 + c2 * v2)[2]} \end{pmatrix}
\end{equation*}
<<calcN,include=FALSE>>=
c1 * v1 + c2 * v2
v1
v2
c1
c2
@
\subQuestion
\begin{equation*}
\vec{n}(1) = c_1 \boldsymbol{A} \vec{v}_1 + c_2 \boldsymbol{A} \vec{v_2}
\end{equation*}
Now we use that
\begin{equation*}
\boldsymbol{A} \vec{v} = \lambda_i \vec{v}_i
\end{equation*}
To find:
\begin{equation*}
\vec{n}(1) = c_1 \lambda_1 \vec{v}_1 + c_2 \lambda_2 \vec{v_2}
\end{equation*}
\subQuestion We know that
\begin{equation*}
\vec{n}(2) = \boldsymbol{A} \vec{n}(1)
\end{equation*}
And thus:
\begin{equation*}
\vec{n}(2) = \boldsymbol{A} \left( c_1 \lambda_1 \vec{v}_1 + c_2 \lambda_2 \vec{v_2} \right) = \boldsymbol{A} c_1 \lambda_1 \vec{v}_1 + \boldsymbol{A} c_2 \lambda_2 \vec{v_2}
\end{equation*}
Because $\lambda_1$ and $\lambda_2$ are just numbers and not matrices, the order doesn't matter and we can therefore write: 
\begin{equation*}
\vec{n}(2) = c_1 \lambda_1 \boldsymbol{A} \vec{v}_1 + c_2 \lambda_2 \boldsymbol{A} \vec{v_2}
\end{equation*}
Which simplifies to:
\begin{equation*}
\vec{n}(2) = c_1 \lambda_1^2 \vec{v}_1 + c_2 \lambda_2^2 \vec{v_2}
\end{equation*}
\subQuestion 
We use the same logic as we used to answer the last two questions to find:
\begin{equation*}
\vec{n}(t) = c_1 \lambda_1^t \vec{v}_1 + c_2 \lambda_2^t \vec{v_2}
\end{equation*}
We checked this answer in \texttt{R}:
<<checking>>=
pop <- function(t){
  c1*lambda1^t*v1 + c2*lambda2^t*v2
}

# time = 1
t(A%*%n)
pop(1)

# time = 2
A%*%A%*%n
pop(2)

# time = 3
A%*%A%*%A%*%n
pop(3)

# time = 4
A%*%A%*%A%*%A%*%n
pop(4)
@
\subQuestion We have the equation:
\begin{equation*}
\vec{n}(t) = c_1 \lambda_1^t \vec{v}_1 + c_2 \lambda_2^t \vec{v_2}
\end{equation*}
if $t$ becomes very big, the term that will dominate this equation will be the one with the highes eigenvalue. So if $t\gg 1$ and $\lambda_1 > \lambda_2$, we will find that $\lambda_1^t \gg \lambda_2^t$. All other numbers in the equations are constants that do not depend on time. As long as these are not 0, we will therefore find:
\begin{equation*}
c_1 \lambda_1^t \vec{v}_1 \gg c_2 \lambda_2^t \vec{v_2}
\end{equation*}
That means that the term with $\vec{v}_1$ will completely dominate the distribution. This is why we find a stable stage distribution for matrix models.
\subQuestion This population grows with a rate equal to $\lambda_1 = \Sexpr{lambda1}$. Since this value is not $1$, it is not really stable. Instead, we are seeing exponential \Sexpr{ifelse(lambda1<1,"decline","increase")}. This means the following: although the distribution in the population is stable (the same ratio of juveniles/adults), overall growth is exponential and the population size changes rapidly!

\end{Answer}


\subsubsection{Reproductive values}
The reproductive value vector represents the contribution of each individual to present and future reproduction. In other words, it gives how much an individual in a given age class contributes to the population on the long-term, including offspring of its offspring. That is: if we have a population and its matrix at time $t=1$, what proportion of individuals at a much later time will be descendants of individuals in age class $1$ at time $t=1$ and how many from individuals in age class $2$ etc. Mathematically, the reproductive value vector is the left eigenvector of the population matrix.
\begin{equation}
\vec{v}A=\lambda \vec{v}
\end{equation}
Please note that this time the vector is on the left side instead of on the right side of the matrix. This is why this is called a left eigenvector. Multiplication with the vector on the left side of the matrix looks as follows in 2 dimensions:
\begin{equation}
\begin{pmatrix} v_1 & v_2 \end{pmatrix} \begin{pmatrix} a_{1,1} & a_{1,2}\\ a_{2,1} & a_{2,2} \end{pmatrix} = \begin{pmatrix} v_1 a_{1,1} + v_2 a_{2,1} & v_1 a_{1,2} + v_2 a_{2,2} \end{pmatrix}
\end{equation}
Again, we take the row from the first element (in this case the vector) and multiply its elements by the elements of the first column of the second element (in these case a matrix). Adding up these contributions gives us the value for the first entry of the final vector. Compare this to what you would get if the order of the matrix and the vector would be the other way around.

To get the left eigenvector of a matrix, we need to perform the eigen analysis on the transpose of the projection matrix. (The transpose of a matrix is the matrix we get by exchanging the rows and the columns of that matrix. For example for the matrix $\boldsymbol{B}=\begin{pmatrix}a & b\\ c & d\end{pmatrix}$, $\boldsymbol{B}^T$ is the transpose of matrix $\boldsymbol{B}$ and $\boldsymbol{B}^T=\begin{pmatrix}a & c\\ b & d\end{pmatrix}$). More visually: when you transpose a matrix, you mirror its elements in the diagonal of that matrix. \texttt{t()} is the \texttt{R} function that transposes a matrix. If you do not remember what the function \texttt{eigen} does, reread the subsection \textit{asymptotic rate of increase} or aks \texttt{R} (\texttt{?eigen}).

<<t18,echo=T,eval=T, results='hide'>>=
At<-t(A)
eigens.At<-eigen(At)
eigens.At
@
Do you notice anything about the eigenvalue? Check that the found dominant left eigenvector is indeed a left eigenvector of the matrix with the dominant eigenvalue as its eigenvalue.\\[1.5ex]
<<t19,echo=F,eval=T, results='hide'>>=
position3<-which.max(eigens.At$values)
lambda3<-eigens.At$values[position3]
v<-eigens.At$vector[,position3]
rv<-v/sum(v)
rv
@
\begin{mdframed}
\textbf{Additional information: Reproductive values more in depth}\\
If you want to understand the interpretation of the reproductive values more closely, take a look at the following (not too elegant) code:
<<testcode>>=
B<-matrix(4*runif(9),nrow=3) # We generate a random matrix

B 
# We output B, in case you want to repeat the 
# simulation yourself

eigen(t(B))$vectors[,1]/sum(eigen(t(B))$vectors[,1])
# We calculate the dominant left eigenvector of this matrix
# and normalise it with respect to the sum of its elements

# Now we want to investigate what would happen to the 
# following 3 initial populations:
# 1) (1,0,0)  2) (0,1,0)  3) (0,0,1)

N1<-rep(NA,3)
# Create an empty vector for storing the final population
# size if we start with any of the three initial populations
for(i in 1:3){
  N<-rep(0,3)
  N[i]<-1
  # Set the initial population vector
  # the first time it will be (1,0,0)
  # then (0,1,0) and finally (0,0,1)
  
  for(t in 1:40){ 
    # we project the population for 40 timesteps
    N<-B%*%N
  }
  N1[i]<-sum(N)
  # We store the total population size after 40 timesteps
  # in the vector N1
}
N1/sum(N1)
# We output the normalised version of N1, which should be
# equal to the left eigenvector, do check this!
@
You can interpret this as follows: if we for example start with a population $\begin{pmatrix}1\\ 1\\ 1 \end{pmatrix}$, after $40$ years, $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the total population will have originated from the individual that was initially in age class $1$, $\Sexpr{100*round(N1[2]/sum(N1),2)}\% $ from the individual in age class $2$ and the remaining $\Sexpr{100*round(N1[3]/sum(N1),2)}\% $ of the total population at timestep $40$ from the individual that was in age class $3$ in the initial population.
\textit{Please note that since we took completely random numbers to construct the matrix, the matrix is unlikely to have biological relevance. But the concept of course remains the same for more relevant matrices.}\\[1.5ex]
However, what would happen if the initial population would look as follows: $\begin{pmatrix}2\\ 1\\ 1 \end{pmatrix}$? If we project this initial population in the future we find (the code is omitted this time):
<<testcode2,echo=FALSE>>=

# We calculate the dominant left eigenvector of this matrix
# and normalise it with respect to the sum of its elements

# Now we want to investigate what would happen to the 
# following initial populations:
# 1) (1,0,0)
# 2) (0,1,0)
# 3) (0,0,1)

N1<-rep(NA,3)
# Create an empty vector for storing the final population
# size if we start with any of the three initial populations
for(i in 1:3){
  
  N<-rep(0,3)
  N[i]<-1
  if(i==1){
    N[i]<-2
  }
  # Set the initial population vector
  # the first time it will be (1,0,0)
  # then (0,1,0) and finally (0,0,1)
  
  for(t in 1:40){ 
    # we project the population for 40 timesteps
    N<-B%*%N
  }
  
  N1[i]<-sum(N)
  # We store the total population size after 40 timesteps
  # in the vector N1
}
N1/sum(N1)
# We output the normalised version of N1, which should be
# equal to the left eigenvector, do check this!
@
This means that after $40$ years, $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the total population will have originated from the two individuals that were initially in age class $1$, $\Sexpr{100*round(N1[2]/sum(N1),2)}\% $ from the individual in age class $2$ and the remaining $\Sexpr{100*round(N1[3]/sum(N1),2)}\% $ of the total population at timestep $40$ from the individual that was in age class $3$ in the initial population. These numbers do not correspond to the left eigenvector, yet they do relate to the left eigenvalue.
First we need to realize that if $\Sexpr{100*round(N1[1]/sum(N1),2)}\% $ of the final population originated from the two individuals in age class 1 in the initial population, this means that each of these two individuals is responsible for $\Sexpr{50*round(N1[1]/sum(N1),2)}\% $ of the final population. It is of course fairer to compare these numbers with each other (so after correcting for the number of individuals that we started with):
\begin{equation*}
\begin{pmatrix}
\Sexpr{50*round(N1[1]/sum(N1),2)} \\
\Sexpr{100*round(N1[2]/sum(N1),2)} \\
\Sexpr{100*round(N1[3]/sum(N1),2)}
\end{pmatrix}
\end{equation*}
However, now the numbers no longer add up to $100\%$. Since all we care about is the ratio between the different contributions, we can just divide all of them by the sum of the three contributions ($\approx \Sexpr{50*round(N1[1]/sum(N1),2)} +\Sexpr{100*round(N1[2]/sum(N1),2)} + \Sexpr{100*round(N1[3]/sum(N1),2)} $) and multiply the total by $100$ (just to make sure that all the percentages add up to $100$). What we get now is: 
\begin{equation*}
\begin{pmatrix}
\Sexpr{round(50*N1[1]/(0.5*N1[1]+N1[2]+N1[3]),2)} \\
\Sexpr{round(100*N1[2]/(0.5*N1[1]+N1[2]+N1[3]),2)} \\
\Sexpr{round(100*N1[3]/(0.5*N1[1]+N1[2]+N1[3]),2)}
\end{pmatrix}
\end{equation*}
This is indeed again the left eigenvector! (Hopefully. Every time we save this document new random numbers are generated, so actually we can only hope that the theory is general enough to work for all random matrices \texttt{B} that are accidentally generated...). We see thus that the left eigenvector actually mainly tell you how many more offspring an individual that starts in a certain age class will have compared to individuals in other age classes on the long term. -- This is indeed a relatively difficult concept, but maybe if you think about it and go over this simulation yourself, it might sink in.
\end{mdframed}

\shipoutAnswer
\end{document}